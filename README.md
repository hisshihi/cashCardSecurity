# **О безопасности**

## Аутентификация

Пользователем API на самом деле может быть человек или другая программа, поэтому часто мы будем использовать термин « Принципал» как синоним слова «пользователь».
Аутентификация — это действие Принципала, подтверждающее его личность системе.
Один из способов сделать это — предоставить учетные данные (например, имя пользователя и пароль с использованием базовой аутентификации ).
Мы говорим, что после предоставления надлежащих учетных данных Принципал аутентифицируется или, другими словами, пользователь успешно вошел в систему.

HTTP — это протокол без отслеживания состояния, поэтому каждый запрос должен содержать данные, подтверждающие, что он поступил от проверенного принципала.
Хотя можно предоставлять учетные данные при каждом запросе, это неэффективно, поскольку требует дополнительной обработки на сервере.
Вместо этого сеанс аутентификации (или сеанс аутентификации, или просто сеанс) создается, когда пользователь проходит аутентификацию.
Сессии могут быть реализованы разными способами. Мы будем использовать общий механизм: токен сеанса (строка случайных символов), который генерируется и помещается в файл cookie.
Файл cookie — это набор данных, хранящихся в веб-клиенте (например, браузере) и связанных с определенным URI.

Несколько приятных особенностей файлов cookie:

Файлы cookie автоматически отправляются на сервер при каждом запросе (для этого не нужно писать дополнительный код).
Пока сервер проверяет действительность токена в файле cookie, неаутентифицированные запросы могут быть отклонены.
Файлы cookie могут сохраняться в течение определенного периода времени, даже если веб-страница закрыта, а затем повторно посещена.
Эта возможность обычно улучшает взаимодействие с пользователем веб-сайта.

## Spring безопасность и аутентификация

Spring Security реализует аутентификацию в Filter Chain.
Цепочка фильтров — это компонент веб-архитектуры Java, который позволяет программистам определять последовательность методов, которые вызываются до контроллера.
Каждый фильтр в цепочке решает, разрешить ли продолжить обработку запроса или нет.
Spring Security вставляет фильтр, который проверяет аутентификацию пользователя и возвращает ответ, 401 UNAUTHORIZED если запрос не аутентифицирован.

## Авторизация

До сих пор мы обсуждали аутентификацию. Но на самом деле аутентификация — это только первый шаг.
Авторизация происходит после аутентификации и позволяет разным пользователям одной системы иметь разные разрешения.

Spring Security обеспечивает авторизацию через управление доступом на основе ролей (RBAC).
Это означает, что Принципал имеет несколько Ролей. Каждый ресурс (или операция) определяет, какие роли должен иметь Принципал, чтобы выполнять действия с надлежащими полномочиями.
Например, пользователю с ролью администратора, скорее всего, будет разрешено выполнять больше действий, чем пользователю с ролью владельца карты.
Вы можете настроить авторизацию на основе ролей как на глобальном уровне, так и для каждого метода.

## Та же политика происхождения

Интернет — опасное место, где злоумышленники постоянно пытаются воспользоваться уязвимостями безопасности.
Самый базовый механизм защиты основан на HTTP-клиентах и серверах, реализующих политику одинакового происхождения (SOP).
Эта политика гласит, что только скрипты, содержащиеся на веб-странице, могут отправлять запросы к источнику (URI) веб-страницы.

СОП имеет решающее значение для безопасности веб-сайтов, поскольку без этой политики любой может написать веб-страницу, содержащую сценарий, который отправляет запросы на любой другой сайт.
Например, давайте посмотрим на типичный банковский веб-сайт. Если пользователь вошел в свой банковский счет и посещает вредоносную веб-страницу (в другой вкладке или окне браузера),
вредоносные запросы могут быть отправлены (с помощью файлов cookie аутентификации) на сайт банка.
Это может привести к нежелательным действиям, например снятию средств с банковского счета пользователя!

Совместное использование ресурсов между источниками
Иногда система состоит из сервисов, работающих на нескольких машинах с разными URI (т. е. микросервисов).
Совместное использование ресурсов между источниками (CORS) — это способ взаимодействия браузеров и серверов для смягчения SOP.
Сервер может явно разрешить список «разрешенных источников» запросов, поступающих из источника, находящегося за пределами сервера.

Spring Security предоставляет @CrossOrigin аннотацию, позволяющую указать список разрешенных сайтов.
Будь осторожен! Если вы используете аннотацию без каких-либо аргументов, она разрешит все источники, так что имейте это в виду!

## О распространнёных вредоносных веб-эксплойтах

### Подделка межсайтового запроса

Одним из типов уязвимостей является подделка межсайтовых запросов (CSRF) , которую часто называют «Sea-Surf» , а также известная как Session Riding.
Сеансовая езда фактически активируется с помощью файлов cookie. CSRF-атаки происходят, когда вредоносный фрагмент кода отправляет запрос на сервер, на котором проходит аутентификация пользователя.
Когда сервер получает файл cookie аутентификации, он не может узнать, отправила ли жертва вредоносный запрос непреднамеренно.

Для защиты от атак CSRF вы можете использовать токен CSRF.
Токен CSRF отличается от токена аутентификации, поскольку при каждом запросе генерируется уникальный токен.
Это затрудняет вмешательство внешнего субъекта в «разговор» между клиентом и сервером.

К счастью, Spring Security имеет встроенную поддержку токенов CSRF, которая включена по умолчанию.

### Межсайтовый скриптинг

Возможно, даже более опасной, чем уязвимость CSRF, является межсайтовый скриптинг (XSS).
Это происходит, когда злоумышленнику каким-то образом удается «обмануть» приложение-жертву, заставив его выполнить произвольный код.
Есть много способов сделать это. Простой пример — сохранение строки в базе данных, содержащей <script>тег, а затем ожидание, пока строка не будет отображена на веб-странице, что приведет к выполнению сценария.

XSS потенциально более опасен, чем CSRF.
В CSRF могут выполняться только те действия, на которые пользователь имеет право. Однако в XSS произвольный вредоносный код выполняется на клиенте или на сервере.
Кроме того, XSS-атаки не зависят от аутентификации. Скорее, XSS-атаки зависят от «дыр» в безопасности, вызванных плохой практикой программирования.

Основным способом защиты от XSS-атак является правильная обработка всех данных из внешних источников (например, веб-форм и строк запросов URI).
В случае нашего <script>примера с тегом атаки можно смягчить, правильно экранируя специальные символы HTML при отображении строки.

## О CSRF

Для целей нашего Family Cash Card API мы собираемся следовать рекомендациям команды Spring Security в отношении клиентов, [не использующих браузер:](https://docs.spring.io/spring-security/site/docs/5.0.x/reference/html/csrf.html#when-to-use-csrf-protection)

Когда вам следует использовать защиту CSRF?
Наша рекомендация заключается в использовании защиты CSRF для любого запроса, который может быть обработан браузером обычными пользователями.
Если вы создаете только службу, используемую клиентами, не являющимися пользователями браузера, вы, скорее всего, захотите отключить защиту CSRF.

Если вы хотите добавить защиту CSRF в наше приложение, пожалуйста, ознакомьтесь с опциями поддержки тестирования, приведенными ниже.

[Примеры тестирования CSRF MockMvc](https://docs.spring.io/spring-security/reference/servlet/test/mockmvc/csrf.html)
[Примеры тестирования CSRF веб-тестового клиента.](https://docs.spring.io/spring-security/site/docs/5.2.0.RELEASE/reference/html/test-webflux.html#csrf-support)
Описание шаблона [двойной отправки файлов cookie.](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#double-submit-cookie)

Сводка по операциям POST, PUT, PATCH и CRUD
![img.png](img.png)
В API Cash Card нам не нужно разрешать PUTсоздание ресурсов. Нам также не нужно добавлять данные на стороне сервера для операции обновления и не нужно разрешать частичное обновление. Итак, наша PUTконечная точка ограничена третьей строкой приведенной выше таблицы.

Строки , выделенные жирным шрифтом в приведенной выше таблице, реализованы API Cash Card. Нежирные — нет.

## [О безопасности приложения по умолчанию](https://spring.academy/courses/spring-academy-secure-rest-api-oauth2/lessons/security-defaults)

Безопасность по умолчанию — это принцип, который призывает вас обеспечить безопасность настроек по умолчанию. Таким образом, если приложение оказывается в рабочей среде с настройками по умолчанию, это не является уязвимостью безопасности.

Принцип наименьших привилегий — это принцип, который побуждает вас относиться к каждому фрагменту данных как к привилегии, которой можно владеть, и предоставлять конечным пользователям минимально возможные привилегии, позволяющие им хорошо выполнять свою работу.

Spring Security использует обе эти философии для автоматической защиты REST API.

### Параметры безопасности Spring по умолчанию

Когда Spring Security находится в пути к классам, Spring Boot настраивает ваше приложение со следующими значениями по умолчанию для REST API:

* Требует аутентификации для всех запросов
* Отвечает безопасными заголовками на все запросы.
* Требуется смягчение CSRF для всех запросов с побочными эффектами.
* Позволяет использовать базовую аутентификацию HTTP с пользователем по умолчанию.
* Реагирует RESTful на сбои безопасности
* Защищает от вредоносных запросов с помощью брандмауэра приложений.

#### Требуется аутентификация для всех запросов

Независимо от того, сгенерирована ли конечная точка вами или сгенерирована загрузкой, все запросы во всех отправках требуют аутентификации.

Независимо от характера конечной точки Spring Security применяет фильтр сервлетов, который проверяет каждый запрос и отклоняет его, если запрос не прошел проверку подлинности.

Это один из безопасных параметров Spring Security по умолчанию.

#### Сервлеты, фильтры и диспетчеры

Чтобы понять это немного лучше, нам нужно охватить небольшой объем терминологии API сервлетов.

API сервлетов Java — это модуль Java для обработки HTTP-запросов внутри приложения. Используя терминологию сервлетов, данный HTTP-запрос может проходить через несколько отправок . Каждая отправка может быть перехвачена несколькими фильтрами на пути к одному сервлету .

Сервлет обрабатывает HTTP- запросы и выдает HTTP-ответ. Вы можете думать о сервлете как о «мини-сервере».

Фильтр перехватывает HTTP-запросы для решения сквозных проблем . Обычно фильтры либо каким-то образом обогащают запрос, либо отклоняют его, не позволяя ему достичь сервлета.

Отправка представляет собой один проход HTTP-запроса через набор фильтров и целевой сервлет . Обычно HTTP-запрос сначала проходит через диспетчеризацию REQUEST, но впоследствии может также пройти через диспетчеризацию ERROR, FORWARD и другие.

В терминах Spring Spring MVC представляет собой один сервлет, Spring Security представляет собой набор фильтров, а Spring Boot поставляется со встроенным контейнером, который выполняет различные диспетчеризации, необходимые для обслуживания одного запроса.

Все это означает, что настройки Spring Security по умолчанию требуют аутентификации каждой отправки .

#### Преимущества безопасности

Преимущество этой схемы заключается в том, что не имеет значения, кто создал конечную точку.
Если это вы, Boot или стороннее лицо, фильтр сервлетов Spring Security перехватывает запрос до того, как какой-либо сервлет («мини-сервер») сможет его обработать.

Это означает, что когда вы включаете Spring Security, даже несуществующие конечные точки будут возвращать 401 Unauthorizedкод состояния ответа HTTP вместо, скажем, 404 Not Found— ответа Spring Boot по умолчанию для несуществующих конечных точек.
Причиной такой строгой политики является принцип наименьших привилегий . Этот принцип гласит, что вы должны предлагать только ту информацию, которую конечный пользователь имеет право знать

В целях безопасности даже то, какие URI действительны, является конфиденциальной информацией. Вы можете себе представить, если бы кто-то запросил index.jsp или /admin . Если бы Spring Security в таких случаях возвращал a 404вместо 401, это означало бы 401намек злоумышленнику на то, что данная конечная точка существует!
Злоумышленник может использовать эту подсказку для перечисления действительных URI REST API, выяснения лежащих в основе уязвимых технологий и [ускорения атаки](https://owasp.org/www-project-top-ten/2017/A9_2017-Using_Components_with_Known_Vulnerabilities) .

### Отвечает безопасными заголовками на все запросы

Заголовки HTTP позволяют клиенту и серверу обмениваться дополнительной информацией друг с другом в HTTP-запросе и ответе.
Независимо от того, аутентифицирован запрос или нет, Spring Security по умолчанию всегда отвечает определенными заголовками. По умолчанию для каждого заголовка установлено наиболее безопасное доступное значение.

#### Кэширование заголовков

Первые — это заголовки управления кэшем. Один из классов уязвимостей браузера заключается в том, что HTTP-ответы кэшируются в браузере. Например, предположим, что ваш REST API вернул следующее:
`[
{
"amount": 123.45,
"id": 99,
"owner": "sarah1"
},
{
"amount": 1.0,
"id": 100,
"owner": "sarah1"
}
]`

Затем этот ответ может быть кэширован в браузере для последующего извлечения злоумышленником на локальном компьютере пользователя.
Или, что более практично, даже если конечный пользователь сам потеряет доступ или отзовет его у клиентского приложения, браузер все равно сможет получить эти конфиденциальные данные из своего кэша.

Spring Security применяет настройки безопасности для Cache-Control и других заголовков для устранения этого класса уязвимостей.

#### Строгий заголовок транспортной безопасности

Второй — заголовок Strict Transport Security. Этот заголовок заставляет браузер обновлять запросы на HTTPS в течение определенного периода времени.

ПРИМЕЧАНИЕ. Поскольку это предназначено для запросов HTTPS, по умолчанию оно не записывается для HTTP-запроса. Учитывая это, вы можете не увидеть этого при локальном тестировании через HTTP.

Уже давно доказано, что HTTPS является важнейшим компонентом безопасного развертывания. Атаки «человек посередине» позволяют просматривать и изменять данные, передаваемые между конечным пользователем и REST API.

Такие атаки смягчаются HTTPS, а заголовок Strict Transport Security сообщает браузеру не отправлять никаких запросов к этому REST API через HTTP. Вместо этого любые HTTP-запросы должны автоматически обновляться браузером до HTTPS.

#### Параметры типа контента

Третий и последний заголовок, о котором мы поговорим на этом этапе, — это заголовок X-Content-Type-Options. Этот заголовок сообщает браузерам, что им не следует пытаться угадать тип содержимого ответа.

Обычно злоумышленники скрываются там, где протокол HTTP нечеток, а приложения пытаются понять, устранить неоднозначность и угадать цель запроса или ответа.
Например, браузер может просмотреть ответ, который начинается с, <html>и обоснованно предположить, что тип контента text/html— то есть веб-страница. Иногда такое гадание небезопасно.
Например, изображение может содержать содержимое сценария, а браузер можно обманом заставить угадать и выполнить его steal-my-password.jpgкак JavaScript.

Spring Security решает эту проблему, устанавливая настройки безопасности X-Content-Type-Optionsпо умолчанию.

### Требуется смягчение CSRF для всех запросов с побочными эффектами

Еще одно место, где REST API подвергаются риску, — это возможность сторонних веб-сайтов отправлять к ним запросы без согласия пользователя.

Это возможно, поскольку браузеры по умолчанию автоматически отправляют все файлы cookie и данные базовой аутентификации HTTP на любую конечную точку, не являющуюся XHR.

Например, взгляните на этот запрос так называемого изображения:
`<img src="https://mybank.example.org/account/32?transfer=25&toAccount=45" />`

Ура! Этот запрос будет выполнен браузером. Это работает, потому что браузер не может узнать, указывает ли URL-адрес на изображение, пока не придет ответ. К тому времени ущерб уже был нанесен.

Как вы можете себе представить, браузеры делают этот запрос даже на сторонних веб-сайтах.
mybank.example.orgБраузеры по умолчанию также отправляют на него все файлы cookie и базовые учетные данные HTTP.
Это означает, что если ваш пользователь вошел в систему, стороннее приложение может управлять вашим REST API без дополнительной защиты.

По этой причине Spring Security автоматически защищает эти конечные точки с помощью побочных эффектов, таких как POST, PUT и DELETE.
Для этого он отправляет клиенту специальный токен, который он должен использовать при последующих запросах. Токен передается таким образом, что третьи лица не могут его увидеть.
Поэтому, когда он возвращается, Spring Security считает, что он законно получен от клиента.

### Разрешает базовую аутентификацию HTTP с пользователем по умолчанию

Вы задавались вопросом об этом, не так ли?

Spring Security генерирует пользователя по умолчанию с именем user. Однако его пароль генерируется при каждом запуске.

Причина этого в том, что если вы случайно развернете настройки Spring Security по умолчанию в рабочей среде, никто не сможет использовать имя пользователя и пароль по умолчанию для управления вашим приложением. Это еще один классический пример создания приложения, защищенного по умолчанию , или, другими словами, приложения, настройки которого по умолчанию безопасны.

Чтобы узнать пароль, вы можете посмотреть журналы запуска Boot по этой строке:
`Using generated security password: fc7e0357-7d82-4a9c-bae7-798887f7d3b3`

UUID в этой строке является паролем. Оно будет отличаться при каждом запуске приложения.

Как уже говорилось, Spring Security по умолчанию примет это имя пользователя и пароль, используя стандарт аутентификации HTTP Basic, с которым у вас будет возможность попрактиковаться буквально через мгновение.

### REST реагирует на сбои безопасности

Spring Security отвечает кодом 401 Unauthorized состояния, если учетные данные неверны или отсутствуют в запросе.
Он также по умолчанию отправляет соответствующие заголовки, чтобы указать тип ожидаемой аутентификации. Подразумеваемое значение a 401 заключается в том, что запрос не аутентифицирован .

Он отвечает кодом 403 Forbidden состояния, когда учетные данные верны, но запрос не авторизован, например, когда конечный пользователь пытается выполнить запрос только для администратора.
Подразумеваемое значение a 403 заключается в том, что запрос неавторизован .

### Защищает от вредоносных запросов с помощью брандмауэра приложений

Существует множество других способов, которыми злоумышленник может попытаться злоупотребить вашим REST API. Для многих из них лучше всего полностью отклонить запрос.

Spring Security помогает вам в этом, добавляя брандмауэр приложений, который по умолчанию отклоняет запросы, содержащие двойное кодирование и несколько небезопасных символов, таких как возврат каретки и перевод строки.
Использование брандмауэра Spring Security помогает устранить целые классы уязвимостей.


# OAuth 2.0

### Первым делом добавляем зависимость

`dependencies {
...
implementation 'org.springframework.boot:spring-boot-starter-oauth2-resource-server'
}`

### Далее мы добавляем открытый ключ в application.yml

Он нужен для проверки нашего jwt токена
`spring:
security:
oauth2:
resourceserver:
jwt:
public-key-location: classpath:authz.pub`
И в папку resources добавляем файл authz.pub
`-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvdpvWwdlN71OeFA62NrJ
wVSPKE+NJqER5DMBQEcmhb03ITECVUpnPwQIjbe0TVNXd+6A0r2MXJuA9LtupjoR
GYiBE9ajaQMGhvEwOx3C4hPELDRb57I+yK7Hh9VKwnmKH2Jg+X6/21MYoQaTTdHT
9vSZmNmcgCnYC/ngzo3eBAn4tuXpmFG5Nmwirp47zRIJJQQvocnpO1mJEwtKkfm/
djRRLfA4iWDfUlWbR9OuX/qTxm/pu8zlO6O/6AlBCeApkUt+wcjrU7z3y2IpO1T0
pwbvyIBie9wuFwABpZ476FU5FpUUAHnjFOVuU7l8rZZNDp3VgVq8S85LA6S3gV31
LQIDAQAB
-----END PUBLIC KEY-----`

### Теперь в application.yml добавляем более подробный вывод данных для spring security
`logging:
level:
org.springframework.security: TRACE`